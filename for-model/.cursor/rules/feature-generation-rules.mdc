---
description: "feature 모듈 코드를 생성할 때 패키지 구조, 고정 생성파일, 유동 생성파일을 구성하는데 참고하여 사용합니다."
alwaysApply: false
---
# Feature Generation Rules - {service name}-feature 모듈

## 패키지 구조

```
{service name}-feature/
├── pom.xml                                    # Maven 프로젝트 설정 (고정 생성)
├── src/
│   ├── main/
│   │   ├── java/
│   │   │   └── com/
│   │   │       └── poscodx/
│   │   │           └── sample/
│   │   │               └── {service name}/
│   │   │                   └── feature/
│   │   │                       ├── action/         # 비즈니스 액션 (유동 생성)
│   │   │                       │   └── {entityName}Action.java
│   │   │                       ├── domain/         # 도메인 서비스 (유동 생성)
│   │   │                       └── flow/           # 비즈니스 플로우 (유동 생성)
│   │   │                           └── {entityName}Flow.java
│   │   └── resources/
```

## 고정 생성 파일들

### 1. pom.xml
Maven 프로젝트 설정 파일로, `@pom-generation-rules`를 참고하여 의존성과 빌드 설정이 정의되어 있습니다.

## 유동 생성 파일들 규칙

DDD 마이크로서비스의 성격에 따라 boundedContext의 Aggregate별 생성될 파일들이며, 해당 메타데이터를 참고하여 유동적으로 세부 코드, 경로가 변경되어야한다.

### 1. {entityName}Action.java (비즈니스 액션)
단일 비즈니스 액션을 처리하는 서비스 클래스입니다.

**생성 규칙:**
- 패키지명: `com.poscodx.sample.{프로젝트명}.feature.action`
- 클래스명: `{entityName}Action` (첫 글자 소문자)
- 어노테이션: `@Service`, `@Transactional`
- 의존성: MessageSource, {entityName}Logic

**예시 코드:**
```java
package com.poscodx.sample.{service name}.feature.action;

import com.poscodx.sample.{service name}.store.domain.logic.projectLogic;
import jakarta.transaction.Transactional;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.context.MessageSource;
import org.springframework.stereotype.Service;

@Slf4j
@RequiredArgsConstructor
@Service
@Transactional
public class projectAction {
    private final MessageSource messageSource;
    private final projectLogic logic;
    
    /* 
    // TODO : Biz Logic 구현 
    // 1. 필요한 컴포넌트 선언 
    private final SomeComponent someComponent; 
    private final SomeLogic someLogic; 

    // 2. 필요한 메소드 정의 및 구현 
    public void someMethod() { 
        someComponent.someMethod(); 
        someLogic.someMethod(); 
        logic.someMethod(); 
    } 
    public String someMessageTest(Locale locale, String ... args) { 
        return messageSource.getMessage("SOME_MESSAGE_ID", args, locale);
    } 
    */ 
}
```

### 2. {entityName}Flow.java (비즈니스 플로우)
복합적인 비즈니스 플로우를 처리하는 서비스 클래스입니다.

**생성 규칙:**
- 패키지명: `com.poscodx.sample.{프로젝트명}.feature.flow`
- 클래스명: `{entityName}Flow` (첫 글자 소문자)
- 어노테이션: `@Service`, `@Transactional`
- 의존성: MessageSource, {entityName}Action

**예시 코드:**
```java
package com.poscodx.sample.{service name}.feature.flow;

import com.poscodx.sample.{service name}.feature.action.projectAction;
import jakarta.transaction.Transactional;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.context.MessageSource;
import org.springframework.stereotype.Service;

@Slf4j
@RequiredArgsConstructor
@Service
@Transactional
public class projectFlow {
    private final MessageSource messageSource;
    private final projectAction action;
    
    /* 
    // TODO : Biz Logic 구현 
    // 1. 필요한 컴포넌트 선언 
    private final SomeComponent someComponent; 
    private final SomeLogic someLogic; 
    private final SomeAction someAction; 

    // 2. 필요한 메소드 정의 및 구현 
    public void someMethod() { 
        someComponent.someMethod(); 
        someLogic.someMethod(); 
        someAction.someMethod(); 
        action.someMethod(); 
    } 
    public String someMessageTest(Locale locale, String ... args) { 
        return messageSource.getMessage("SOME_MESSAGE_ID", args, locale);
    } 
    */ 
}
```

## 생성 지침

1. **고정 생성 파일들**은 위에 명시된 내용을 기반으로 서비스명에 맞게 생성합니다.
2. **유동 생성 파일들**은 도메인 엔티티 메타데이터를 기반으로 동적으로 생성합니다.
3. **패키지 구조**는 `com.poscodx.sample.{service name}` 형태로 통일합니다.
4. 모든 서비스 클래스는 `@Service`와 `@Transactional` 어노테이션을 포함해야 합니다.
5. Action 클래스는 단일 비즈니스 로직 처리에 집중하고, Flow 클래스는 여러 Action을 조합한 복합 로직을 처리합니다.
6. 의존성 주입은 생성자 주입 방식(`@RequiredArgsConstructor`)을 사용합니다.
7. **DDD 마이크로서비스 기반 변경사항**: 파일의 경로와 세부 내용은 DDD 마이크로서비스에 의거하여 변경되어야 하는 사항들에 대해 Metadata를 참조하여 만들어야 합니다.
